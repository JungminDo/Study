<!DOCTYPE html>
<html lang="kr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Script5장</title>
    <script src="http://code.jquery.com/jquery-latest.min.js"></script>
    <link rel="stylesheet" href="JAVAScript5장.css">
    <script src="JAVAScript5장.js"></script>

</head>

<body>

    <!--
    <ul class="navigation">
        <li>HTML</li>
        <li>CSS</li>
        <li>javascript</li>
        <li class="selected">$사용충돌방지</li>
        <li>function($)</li>
        <li>$를 로컬변수로</li>
    </ul>
-->

    <br/ />

    <fieldset>
        <legend> 기본 </legend>
        <div class="sample">
            <ul id="tutorials">
                <li class="tutorial" id="HTML"> HTML </li>
                <li class="tutorial" id="CSS"> CSS </li>
                <li class="tutorial" id="javascript"> javascript </li>
                <li class="tutorial" id="jquery"> jQuery </li>
                <li class="tutorial" id="PHP"> PHP </li>
                <li class="tutorial" id="MYSQL"> MYSQL </li>
            </ul>
            <textarea>
            <ul id="tutorials">
                <li class="tutorial" id="HTML"> HTML </li>
                <li class="tutorial" id="CSS"> CSS </li>
                <li class="tutorial" id="javascript"> javascript </li>
                <li class="tutorial" id="jquery"> jQuery </li>
                <li jclass="tutorial" id="PHP"> PHP </li>
                <li class="tutorial" id="MYSQL"> MYSQL </li>
            </ul>
        </textarea>
            <div class="clear"></div>
        </div>
        <input class="btn" type="button" id="#jquerybtn" value="#jquery" /> - id 선택자 <br/ />
        <input class="btn" type="button" id=".tutorial" value=".tutorial" /> - class 선택자 <br/ />
        <input class="btn" type="button" value="li" /> - 엘리먼트 선택자 <br/ />
        <input class="btn" type="button" value="#jquery, #MYSQL" /> - 다중 선택자 <br/ />
    </fieldset>


    <fieldset>
        <legend> filter </legend>
        <div class="sample">
            <ul id="list">
                <li> HTML </li>
                <li> CSS </li>
                <li> javascript </li>
                <li> PHP </li>
                <li> MYSQL </li>
            </ul>
            <textarea>
            <ul id="list">
                <li> HTML </li>
                <li> CSS </li>
                <li> javascript </li>
                <li> PHP </li>
                <li> MYSQL </li>
            </ul>
        </textarea>
            <div class="clear"></div>
        </div>
        <input class="btn" type="button" value="#list li:eq(2)" /> - 인자와 인덱스가 동일한 엘리먼트를 찾아내는 선택자 <br/ />
        <input class="btn" type="button" value="#list li:gt(1)" /> - 인자 보다 인덱스가 큰 엘리먼트를 찾아내는 선택자 <br/ />
        <input class="btn" type="button" value="#list li:lt(2)" /> - 인자 보다 인덱스가 작은 엘리먼트를 찾아내는 선택자 <br/ />
        <input class="btn" type="button" value="#list li:even" /> - 첫번째, 세번째... 홀 수의 인덱스 값을 가진 엘리먼트에 대한 선택자 <br/ />
        <input class="btn" type="button" value="#list li:odd" /> - 두번째, 네번째.... 짝 수의 인덱스 값을 가진 엘리먼트에 대한 선택자 <br/ />
        <input class="btn" type="button" value="#list li:first" /> - 첫번재 인덱스 엘리먼트에 대한 선택자 <br/ />
        <input class="btn" type="button" value="#list li:last" /> - 마지막 인덱스 엘리먼트에 대한 선택자 <br/ />
    </fieldset>


    <fieldset>
        <legend> 속성 </legend>
        <div class="sample">
            <ul id="attribute">
                <li target="ABCD">ABCD</li>
                <li target="BCDE">BCDE</li>
                <li target="CDEF">CDEF</li>
                <li target="DEFG">DEFG</li>
                <li target="EFGH">EFGH</li>
                <li id="FGHI" target="FGHI">FGHI</li>
            </ul>
            <textarea>
            <ul id="attribute">
                <li target="ABCD">ABCD</li>
                <li target="BCDE">BCDE</li>
                <li target="CDEF">CDEF</li>
                <li target="DEFG">DEFG</li>
                <li target="EFGH">EFGH</li>
                <li id="FGHI" target="FGHI">FGHI</li>
            </ul>
        </textarea>
            <div class="clear"></div>
        </div>
        <input class="btn" type="button" value="[target*=&quot;BC&quot;]" /> - 속성의 값에 주어진 문자열이 포함되는 엘리먼트를 찾아내는 선택자
        <br/ />
        <input class="btn" type="button" value="[target=&quot;DEFG&quot;]" /> - 속성의 값과 주어진 문자열이 일치하는 엘리먼트를 찾아내는 선택자
        <br/ />
        <input class="btn" type="button" value="[target!=&quot;DEFG&quot;]" /> - 속성의 값과 주어진 문자열이 일치하지 않는 엘리먼트를 찾아내는 선택자
        <br/ />
        <input class="btn" type="button" value="[target^=&quot;B&quot;]" /> - 속성의 값으로 주어진 문자열이 처음 등장하는 엘리먼트를 찾아내는 선택자
        <br/ />
        <input class="btn" type="button" value="[target$=&quot;H&quot;]" /> - 속성의 값으로 주어진 문자열이 마지막으로 등장하는 엘리먼트를 찾아내는 선택자
        <br/ />
        <input class="btn" type="button" value="[target]" /> - 속성이 존재하는 엘리먼트를 찾아내는 선택자 <br/ />
        <input class="btn" type="button" value="[target][id]" /> - 속성들이 존재하는 엘리먼트를 찾아내는 선택자
    </fieldset>
    <fieldset>
        <legend>Form</legend>
        <div class="live">
            <div>
                <input type="text" disabled="disabled" value="disabled" />
                <input type="text" value="enabled" />
            </div>
            <div><input type="checkbox" checked="checked" /></div>
            <div><input type="checkbox" /></div>
        </div>
        <textarea class="sample">
                    <div>
                        <input type="text" disabled="disabled" value="disabled" />
                        <input type="text" value="enabled"/>
                    </div>
                    <div><input type="checkbox" checked="checked" /></div>
                    <div><input type="checkbox" /></div>
                </textarea>
        <div class="clear"></div>
        <input class="btn" type="button" value="[type=&quot;text&quot;]" /> - 폼 엘리먼트를 선택할 때는 속성 셀렉터를 사용한다. <br/ />
        <input class="btn" type="button" value="[type=&quot;text&quot;]:disabled" /> - disabled 속성의 값이 disabled인 엘리먼트를
        찾아내는 선택자<br/ />
        <input class="btn" type="button" value="[type=&quot;text&quot;]:enabled" /> - disabled 속성의 값이 enabled인 엘리먼트를
        찾아내는 선택자<br/ />
        <input class="btn" type="button" value="input:checked" /> - 체크박스 중 체크가 된 엘리먼트를 찾아내는 선택자 <br/ />
    </fieldset>

    <br/ />

    <section>

    <a id="tutorial22" href="http://jquery.com" target="_self">jQuery</a>

    <br/ />
    <br/ />

    <input id="click_me" type="button" value="click me">
    <input id="remove_event" type="button" value="unbind">
    <input id="trigger_event" type="button" value="trigger">

    <p class="element">
        I would like to say:
    </p>

    <p class="remove-p">
        Hwo?
    </p>

    <p class="replace-p">
        no~~ change me!
    </p>

    <br/ />

    <button class="remove-btn">
        Call remove() on paragraphs
    </button>

    <br/ />

    <button class="replaceAll-btn">
        replaceAll() on
    </button>

    <br/ />

    <button class="replaceWith-btn">
        replaceWith() on
    </button>

    <div class="classtest">
        <p class="blue">Click to toggle </p>
        <p class="blue highlight"> highlight </p>
        <p class="blue"> on these </p>
        <p class="blue"> paragraphs </p>
    </div>

    <br/ />
    <br/ />

    <input class="attr-ctl" type="text" value="some text" />

    <p class="text-ctl">

    </p>

    <br/ />

    <div>
        <p><strong>수의 연산</strong></p>
        <p>Math.pow(3,2); // 9, 3의2승</p>
        <p>Math.round(10.6); // 11, 10.6을 반올림</p>
        <p>Math.ceil(10.2); // 11, 10.2을 올림</p>
        <p>Math.floor(10.6); // 10, 10.6을 내림</p>
        <p>Math.sqrt(9); // 3, 3의 제곱근</p>
        <p>Math.random(); // 0부터, 1.0 사이의 랜덤한 숫자</p>
        <p><strong>문자의 표현 string</strong></p>
        <p>alert('coding everyday') 작은 따옴표는 작은 따옴표로 끝나야 한다.</p>
        <p>alert("coding everyday") 큰은 따옴표는 큰 따옴표로 끝나야 한다.</p>
        <p>alert(typeof"1") 숫자를 따옴표로 감싸면 문자가 된다. typeof는 데이터 형을 알려준다.</p>
        <p>alert(typeof 1 ) 따옴표가 없으면 숫자로 출력 </p>
        <p>alert('kipgoing\'s javascript') 작은 따옴표를 문자열 안에 포함시킬수 있다.</p>
        <p>alert('안녕하세요.\n 코딩을 해봅시다.') \n은 줄바꿈을 의미하는 특수한 문자이다.</p>
        <p>alert('coding'+'good')문자와 문자를 더할 때는 + 기호를 넣어준다.</p>
        <p>alert('coding good'.length)뒤에 .length 를 붙이면 문자의 길이를 구한다.</p>
    </div>

    <br/ />
    <br/ />

    <div>
        <p>prompt() 구문은 사용자가 입력한 값을 가져와서 id 변수의 값으로 대입한다. api 또는 함수</p>
        <p>boolean 의 대체재 로는 0(true) 과 1(false) 가 있다. </p>
        <p>while 문 은 while(조건) 괄호안의 조건이 참이면 중괄호 안의 코드 구간을 반복적으로 실행한다.</p>
        <p>함수 내에서 사용한 return 은 return 뒤에 따라오는 값을 함수의 결과로 반환한다.</p>
        <p>인자란? 인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 <br/ />
            따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다.</p>
    </div>

    <div>
        <p>
            배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해서 사용하는 데이터 타입이다. 변수가 하나의 데이터를 <br/ />
            저장하기 위한 것이라면 배열은 여러개의 데이터를 하나의 변수에 저장하기 위한 것이다
        </p>
        <p>var name = 'kor' name 이라는 변수에 문자 kor 이 할당되고 name 을 호출하면 문자 kor 이 온다.</p>
        <p>여러개의 데이터를 배열에 넣을려면 [ ] 를 쓰고 콤마(,) 로 구분지어주면된다.</p>
        <p>var name = ['kor', 'jpa', 'hong']</p>
        <p>하나의 변수에 3개의 데이터를 담았다. 각각의 데이터를 원소(element)라고 부른다. 데이터를 불러오려면</p>
        <p>alert(name[0]); 이라고 불러오면된다.</p>
    </div>

    <div>객체의 생성방법</div>
    <div>API 란 ? Application Programming Interface 의 약자로 프로그램이 동작하는 환경을 제어하기 위해서 한경에서 제공되는
        조작 장치이다. 이 조작 장치는 프로그래밍 언어를 통해서 조작할 수 있다.
    </div>

    <div>정규 표현식 패턴
        var pattern = /a/

        정규 표현식 객체 생성자
        var pattern = new RegExp('a');

        두가지 모두 같은 결과를 만들지만 각자의 장단점이 존재한다.

    </div>

    <p>자바스크립트에서는 블록 유효범위를 생성하지 않고 함수 단위의 유효범위만 생성된다.</p>
    <p>undefined 선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할경우</p>
    <p>null 은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 또는 함수가 호출되었으나 유효한 값을 </p>
    <p>반환할 수 없는 경우 명시적으로 null을 반환하기도한다.</p>

    <h2>변수 호이스팅</h2>
    <p>자바스크립트의 특징으로 모든 선언문은 호이스팅 되기때문이며 호이스팅이란 var 이나 fuction 등 </p>
    <p>모든 선언문이 해당 Scop 의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉 자바스크립트는 모든 선언문이</p>
    <p>var, let, const, function, function*, class 가 선언되기 이전에 참조 가능하다.</p>
    <p>변수는 3단계에 걸쳐 생성되는데 </p>
    <p>1.선언 단계: 변수 객체에 변수를 등록한다. 이변수 객체는 스코프가 참조하는 대상이 된다.</p>
    <p>2.초기화 단계: 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.</p>
    <p>3.할당 단계: undefined로 초기화된 변수에 실제 값을 할당한다.</p>
    <p>break문</p>
    <p>break 문은 레이블문 반복문 또는 switch문의 코드블록을 탈출한다. 이외에 사용하면 에러가 발생한다.</p>
    <p>continue문</p>
    <p>continue문은 반복문 (for, for..in, for...of, while, do..while)의 코드 블록 실행을 현 지점에서</p>
    <p>중단 하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.</p>
    <p>타입변환</p>
    <p>명시적 타입변환 또는 타입 캐스팅</p>
    <p>Pass-by-reference</p>
    <p>참조타입이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미하며, 원시 타입은</p>
    <p>값이 한번 정해지면 변경할 수 없지만, 객체는 프로퍼티를 변경, 추가, 삭제 가 가능하므로 변경 가능한 값이라 할 수 있다.</p>
    <p>따라서 객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기</p>
    <p>때문에 런타임에 메모리 공간을 확보하고 메모리의 힙 영역에 저장된다.</p>
    <p>이에 반해 원시 타입은 값으로 전달된다.</p>
    <p>Pass-by-value</p>
    <p>원시 타입은 값으로 전달도니다 즉 값이 복사되어 전달된다. 이를 pass-by-value 라 한다.</p>
    <p>원시 타입은 값이 한번 정해지면 변경할 수 없으며 이들 값은 런타임에 메모리의 스택 영역에 고정된</p>
    <p>메모리 영역을 점유하고 저장된다. </p>
    <p>스코프(Scope,유효범위)</p>
    <p>스코프는 참조 대상 식별자(identifier,변수, 함수의 이름과 같이 어떤대상을 다른 대상과 구분하여 식별할 수 있는</p>
    <p>유일한 이름)을 찾아내기 위한 규칙이다. </p>
    <p>var x = 'global';

        function koo(){
            var x = 'function scope';
            console.log(x);
        }

        koo();
        console.log(x);</p>
        <p>위 예제에서 전역에 선언된 변수 x 는 어디에든 참조할 수 있다. 하지만 함수 koo 내에서 선언된 변수 x 는 함수</p>
        <p>koo 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다. 이러한 규칙을 스코프라고 한다.</p>
        <p><strong>전역 스코프: 코드 어디에서든지 참조할 수 있다.</strong></p>
        <p><strong>지역 스코프: 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.</strong></p>
        <p>전역 변수: 전역에서 선언된 변수이며 어디에든 참조할 수 있다.</p>
        <p>지역 변수: 지역(함수)내에서 선언된 변수이며 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.</p>
        <p>블록 레벨 스코프 블록 레벨 스코프란 코드 블록 ({..}) 내에서 유효한 스코프를 의미한다. </p>
        <p>여기서 유효하다란 것은 참조(접근) 할 수 있다라는 뜻이다.</p>
        <p>하지만 자바스크립트는 블록 레벨 스코프를 사용하지 않으므로 함수 밖에서 선언된 변수는</p>
        <p>코드 블록 내에서 선언되었다할지라도 모두 전역 스코프를 갖게된다.</p>
        <p>자바스크립트는 <strong>함수 레벨 스코프를 사용한다.</strong> 즉, 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 </p>
        <p>유효하지 않다. 따라서 변수 b 는 지역 변수이다.</p>
        <p>전역변수 x 와 지역변수 x 가 중복 선언되었다. 전역 영역에서는 전역변수만이 참조 가능하고 함수 내 지역 영역에서는 전역과 </p>
        <p>지역 변수 모두 참조 가능하나 예제와 같이 변수명이 중복된 경우, 지역변수를 우선하여 참조한다. js451~ 459참조</p>


        <div>
            <h2>블록 스코프</h2>
            <p>블록 스코프는 중괄호 {} 로 감싸진 범위를 말한다.</p>
            <p>if(true){
                var variable1 = 'I am in a block';
                let variable2 = 'I am in a block';
                const variable3 = 'I am in a blick';
                console.log(variable1); console.log(variable2); console.log(variable3);
            }
            </p>

            <p>
            for(var i = 0; i &#60; 2; i++){
                var variable1 = 'I am in a block';
                let variable2 = 'I am in a block';
                const variable3 = 'I am in a blick';
                console.log(variable1); console.log(variable2); console.log(variable3);
            }
            </p>

            <p>
            function func(){
                var variable1 = 'I am in a block';
                let variable2 = 'I am in a block';
                const variable3 = 'I am in a blick';
                console.log(variable1); console.log(variable2); console.log(variable3);
            }
            </p>

            <p>if, for, function 의 블록 {} 모두 블록 스코프라고 할 수 있다.</p>

            <h2>함수 스코프</h2>
            <p>함수 스코프는 블록 스코프 중 함수 (function(){}) 범위를 갖는 스코프를 말한다.</p>
            <p>
                function func(){
                    var variable1 = 'I am in a block';
                    let variable2 = 'I am in a block';
                    const variable3 = 'I am in a blick';
                    console.log(variable1); console.log(variable2); console.log(variable3);
                }
            </p>
            <h2>var 의 특징</h2>
            <p>자바 스크립트의 전역 스코프는 함수 스코프의 내부와 동일하게 동작한다.</p>
            <p>var 이 함수 스코프에서 유효하게 동작한다. </p>
            <p>함수 스코프 안에서 var 로 작성된 선언문이 한번 실행된다면 그 함수가 종료되기 전까지 유효하다.</p>

            var a = 1; <br/>
            var b = 2; <br/>
            console.log(a+b); <br/>
                <br/>
            function main(){ <br/>
                var a = 1;  <br/>
                var b = 2;  <br/>
                console.log(a+b); <br/>
            }
            main();

            <p><h2>let 의 특징</h2></p>
            <p>let 은 정의되지 않았다는 에러가 발생한다. 중복 선언시에도 외부 스코프가 내부 스코프와</p>
            <p>다르게 할당된다 또한 블록 스코프에서 유효하다.</p>

            <p><h2>const 의 특징</h2></p>
            <p>const는 let 의 모든 특징을 가지고 있지만 좀 더 엄격하다. 블록스코프에서 유효하다.</p>
            <p>선언과 동시에 할당이 이루어져야 하고, 재할당이 불가하다.</p>
            <p>const 변수 초기화시 값 할당이 이루어지지 않으면 에러가 발생한다.</p>
            <p>또한 한번 선언된 const변수는 재할당할 수 없다. 재할당하려하면 에러가 발생한다.</p>
            <p>const 변수는 db환경정보, api응닫값 등 변하지 않을 값들을 담을 때 사용한다.</p>

            <p><h2>호이스팅(Hoisting)</h2></p>
            <p>호이스팅은 var을 통해 정의된 변수의 선언문을 유효 범위의 최상단으로 끌어올리는 행위를 말한다.</p>
            <p>선언과 할당의 분리 라고 생각하자</p>
            <p>
                if (true){
                var name = 'korean';
            }
            console.log(name); 이코드는
            </p>

            <p>호이스팅에 의해 아래와 같이 바뀌게 된다.</p>
            <p>
                var name; //선언
                if(true){
                    name = 'korean'; //할당
                }
                console.log(name);
            </p>
            <p>var name = 'korean' 이라고 정의한 변수가 실제로는 선언(var name)과 할당(name = 'korean')</p>
            <p>이 분리 되어 여전히 name 이라는 변수를 사용할 수 있다.</p>
            <p>var 의 유효범위</p>
            <p>호이스팅시 선언문은 유효범위의 최상단으로 올라간다, 자바스크립트의 var는 단순한 블록 {} 이 아닌</p>
            <p>함수 블록 function{} 안에서 유효하며 이를 var는 함수 스코프에서 유효하다고 한다.</p>
            <div>
                <h2>직접 작성한 코드</h2>
            function ko1(){
                if(true) {
                    var name = 'korean';
                }
                console.log(name);
            }

            function ko2() {
                for(var i=0; &#60 5; i++ ) {

                }
                console.log(i);
            }

            if(true){
                var score = 100l
            }
            console.log(score);

        </div>
        <div>
            <h2>호이스팅으로 변환된 코드</h2>

            var scroe; //선언

            function ko1(){
                var name; //선언

                if(true){
                    name = 'korean'; //할당
                }
                console.log(name);
            }

            function ko2(){
                var i; //선언

                for(i=0; i &#60 5; i++) { //할당

                }
                console.lig(i);
            }

            if(true){
                score = 100; // 할당
            }
            console.log(score);

        </div>
            <p>var 는 함수 스코프에서 유효하기 때문에 호이스팅 시, 선언문은 글로벌 스코프가 아닌 유효범위(함수)</p>
            <p>배누의 최상단에 위치하게 되고 글로벌 스코프 또한 하나의 함수 스코프 처럼 동작하기 때문에 호이스팅이 일어난다.</p>
            <p><h2>함수 호이스팅</h2></p>
            <p>함수의 선언 역시 호이스팅의 대상이다. 때문에 스코프 내에서 어떤 위치에서 함수 선언을 하든지 호출할 수 있다.</p>
            <p><strong>함수, 변수 우선순위</strong></p>
            <p>var 변수, 함수 선언식을 사용한 함수의 선언부가 유효범위의 최상단으로 호이스팅된다.</p>
            <p>변수 a 선언 > 함수 a선언 > a 에 값 할당 순으로 실행된다.</p>
            <p>var > function > console.log() 순이다.</p>
        </div>

        <div>
            <h2>클로저(Closure) </h2>
            <p>1. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.</p>
            <p>2. 함수 내부에서 함수를 선언할 때, 내부의 함수는 클로저라 부른다.</p>
            <p>이 클로저는 외부 함수에서 생성된 변수들에 접근할 수 있는 권한을 가지고있다.</p>
            <p><h2>클로저를 통해 얻는것들</h2></p>
            <p>1. 원하는 시점에서 내부 클로저를 실행할 수 있다.</p>
            <p>2. private 변수를 가질수 있다.</p>
            <p>3. 함수밖에서 선언된 변수를 함수 내부에서 사용할 때 클로저가 생겨난다.</p>
        </div>




    </section>

</body>

</html>